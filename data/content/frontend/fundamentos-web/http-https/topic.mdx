---
title: "HTTP e HTTPS"
slug: "http-https"
room: "frontend"
category: "fundamentos-web"
difficulty: "beginner"
order: 1
prerequisites: []
tags: ["protocolo", "web", "seguranca"]
aiGenerated: true
---

## O que Ã©

**HTTP** (HyperText Transfer Protocol) Ã© o protocolo de comunicaÃ§Ã£o da web â€” a "linguagem" que navegadores e servidores usam para trocar informaÃ§Ãµes. Toda vez que vocÃª acessa um site, seu navegador envia uma **requisiÃ§Ã£o HTTP** e o servidor responde com uma **resposta HTTP**.

**HTTPS** Ã© HTTP + **TLS/SSL** (criptografia). A comunicaÃ§Ã£o Ã© encriptada ponta a ponta, impedindo que terceiros leiam ou modifiquem os dados em trÃ¢nsito.

```
HTTP:  Navegador â”€â”€[dados em texto puro]â”€â”€â†’ Servidor
       Qualquer pessoa na rede pode ler os dados

HTTPS: Navegador â”€â”€[ğŸ”’ dados criptografados]â”€â”€â†’ Servidor
       Mesmo interceptando, nÃ£o consegue ler
```

## Por que importa

HTTP Ã© o **alicerce da web**. Todo desenvolvedor web â€” frontend ou backend â€” trabalha com HTTP diariamente. Sem entender HTTP:

- VocÃª nÃ£o sabe por que sua requisiÃ§Ã£o retornou erro 404 ou 500
- NÃ£o entende por que CORS bloqueou sua chamada de API
- NÃ£o sabe a diferenÃ§a entre GET e POST (e quando usar cada um)
- NÃ£o consegue debugar problemas de rede usando DevTools

HTTPS Ã© obrigatÃ³rio para qualquer site moderno:
- Google penaliza sites HTTP no ranking de busca
- Navegadores mostram aviso "NÃ£o seguro" para HTTP
- Credenciais (login, cartÃ£o de crÃ©dito) enviadas via HTTP podem ser interceptadas

## Como funciona

### Modelo request-response

HTTP Ã© **stateless** (sem estado) e baseado em **request-response**: o cliente envia uma requisiÃ§Ã£o, o servidor processa e retorna uma resposta. Cada requisiÃ§Ã£o Ã© independente â€” o servidor nÃ£o "lembra" das anteriores.

```
Cliente (navegador)                    Servidor
       â”‚                                  â”‚
       â”‚â”€â”€â”€â”€ Request (GET /index.html) â”€â”€â†’â”‚
       â”‚                                  â”‚ Processa
       â”‚â†â”€â”€ Response (200 OK + HTML) â”€â”€â”€â”€â”€â”‚
       â”‚                                  â”‚
       â”‚â”€â”€â”€â”€ Request (GET /style.css) â”€â”€â”€â†’â”‚
       â”‚                                  â”‚ Processa
       â”‚â†â”€â”€ Response (200 OK + CSS) â”€â”€â”€â”€â”€â”€â”‚
```

### Anatomia de uma requisiÃ§Ã£o HTTP

```
GET /api/users?page=1 HTTP/1.1        â† Linha de requisiÃ§Ã£o (mÃ©todo, path, versÃ£o)
Host: api.example.com                  â† Headers (metadados)
Accept: application/json
Authorization: Bearer eyJhbGci...
User-Agent: Mozilla/5.0
                                       â† Linha vazia (separa headers do body)
                                       â† Body (vazio em GET, dados em POST)
```

**Componentes:**
- **MÃ©todo:** o que vocÃª quer fazer (GET, POST, PUT, DELETE)
- **Path:** o recurso que vocÃª quer acessar (`/api/users`)
- **Headers:** metadados (tipo de conteÃºdo, autenticaÃ§Ã£o, cache)
- **Body:** dados enviados (em POST, PUT, PATCH)

### Anatomia de uma resposta HTTP

```
HTTP/1.1 200 OK                        â† Linha de status (versÃ£o, cÃ³digo, mensagem)
Content-Type: application/json         â† Headers
Content-Length: 234
Cache-Control: max-age=3600
Set-Cookie: session=abc123
                                       â† Linha vazia
{"users": [{"id": 1, "name": "JoÃ£o"}]} â† Body (conteÃºdo da resposta)
```

### Como HTTPS funciona (TLS Handshake)

Pense no HTTPS como enviar uma carta em um cofre trancado. Primeiro, vocÃª e o destinatÃ¡rio precisam combinar a chave do cofre â€” mas como combinar uma chave secreta sem que alguÃ©m intercepte? A soluÃ§Ã£o: o servidor envia um **cadeado aberto** (chave pÃºblica) que qualquer um pode ver, mas sÃ³ o servidor tem a chave para abrir. VocÃª tranca o cofre com esse cadeado, envia, e a partir daÃ­ vocÃªs usam uma chave compartilhada para trocar mensagens.

Antes de trocar dados, cliente e servidor estabelecem uma conexÃ£o segura:

```
Cliente                              Servidor
   â”‚                                    â”‚
   â”‚â”€â”€ 1. ClientHello (versÃ£o TLS) â”€â”€â”€â†’â”‚
   â”‚                                    â”‚
   â”‚â†â”€ 2. ServerHello + Certificado â”€â”€â”€â”‚  (certificado contÃ©m chave pÃºblica)
   â”‚                                    â”‚
   â”‚â”€â”€ 3. Verificar certificado â”€â”€â”€â”€â”€â”€â†’â”‚  (cliente valida com CA)
   â”‚                                    â”‚
   â”‚â”€â”€ 4. Gerar chave de sessÃ£o â”€â”€â”€â”€â”€â”€â†’â”‚  (encriptada com chave pÃºblica)
   â”‚                                    â”‚
   â”‚â†â”€ 5. ConfirmaÃ§Ã£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚                                    â”‚
   â”‚â•â• 6. Dados criptografados â•â•â•â•â•â•â•â”‚  (usando chave de sessÃ£o simÃ©trica)
```

**Resumo:** o handshake usa criptografia assimÃ©trica (cadeado pÃºblico â€” lenta, mas segura para o primeiro contato) para combinar uma chave simÃ©trica (chave compartilhada â€” rÃ¡pida para o dia a dia). Depois, toda comunicaÃ§Ã£o usa a chave simÃ©trica.

### HTTP/1.1 vs HTTP/2 vs HTTP/3

As versÃµes mais novas do HTTP sÃ£o mais rÃ¡pidas, mas a "linguagem" (mÃ©todos, headers, status codes) continua a mesma. A diferenÃ§a principal Ã© **como os dados trafegam pela rede**:

- **HTTP/1.1:** uma requisiÃ§Ã£o por vez por conexÃ£o (como um caixa de supermercado que atende um cliente de cada vez)
- **HTTP/2:** multiplexing â€” vÃ¡rias requisiÃ§Ãµes simultÃ¢neas na mesma conexÃ£o (como um caixa que processa vÃ¡rios itens ao mesmo tempo)
- **HTTP/3:** mesma ideia do HTTP/2, mas usando um protocolo de transporte mais rÃ¡pido (QUIC, baseado em UDP ao invÃ©s de TCP)

Na prÃ¡tica, vocÃª nÃ£o precisa mudar seu cÃ³digo â€” o navegador e o servidor negociam a versÃ£o automaticamente.

## Na prÃ¡tica

VocÃª pode inspecionar qualquer requisiÃ§Ã£o HTTP no navegador:

```
DevTools â†’ Network tab â†’ Clicar em qualquer requisiÃ§Ã£o

General:
  Request URL: https://api.example.com/users
  Request Method: GET
  Status Code: 200 OK

Request Headers:
  Accept: application/json
  Authorization: Bearer eyJhbGci...

Response Headers:
  Content-Type: application/json
  Cache-Control: max-age=300

Response Body:
  {"users": [...]}
```

Ou via terminal com `curl`:
```bash
# RequisiÃ§Ã£o GET simples
curl https://api.example.com/users

# Ver headers da resposta
curl -I https://api.example.com/users

# Enviar POST com JSON
curl -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -d '{"name": "JoÃ£o", "email": "joao@email.com"}'
```

## Quando usar (e quando nÃ£o usar)

### HTTPS â€” use SEMPRE:
- Todo site em produÃ§Ã£o, sem exceÃ§Ã£o
- APIs que trafegam dados de usuÃ¡rios
- Qualquer formulÃ¡rio (login, cadastro, pagamento)

### HTTP â€” aceitÃ¡vel apenas para:
- Desenvolvimento local (`localhost`)
- Ambientes internos isolados (e mesmo assim, HTTPS Ã© preferÃ­vel)

## Erros comuns

### 1. Enviar dados sensÃ­veis via HTTP

```
âŒ http://site.com/login  (credenciais em texto puro na rede)
âœ… https://site.com/login (criptografado)
```

Mesmo em redes "seguras" (Wi-Fi com senha), HTTP pode ser interceptado.

### 2. Mixed content (HTTPS + recursos HTTP)

```html
<!-- Site HTTPS carregando recurso HTTP â†’ navegador bloqueia -->
<img src="http://cdn.example.com/image.png">
<!-- âŒ Blocked: mixed content -->

<!-- âœ… Use HTTPS ou URLs relativas ao protocolo -->
<img src="https://cdn.example.com/image.png">
```

### 3. NÃ£o entender que HTTP Ã© stateless

```
RequisiÃ§Ã£o 1: POST /login (autenticaÃ§Ã£o)
RequisiÃ§Ã£o 2: GET /dashboard â†’ "NÃ£o autorizado!"

Por quÃª? HTTP nÃ£o "lembra" que vocÃª logou.
SoluÃ§Ã£o: cookies de sessÃ£o ou tokens em cada requisiÃ§Ã£o.
```

### 4. Ignorar headers de cache

```
Sem Cache-Control: navegador pode cachear respostas antigas
â†’ UsuÃ¡rio vÃª dados desatualizados
â†’ "Limpa o cache" vira a soluÃ§Ã£o para tudo

Com Cache-Control: max-age=0, no-cache
â†’ Sempre busca dados frescos
```

### 5. Certificado expirado em produÃ§Ã£o

Certificados TLS expiram (geralmente a cada 90 dias com Let's Encrypt). Se expirar:
- Navegador mostra "ConexÃ£o nÃ£o segura"
- UsuÃ¡rios nÃ£o conseguem acessar
- SEO cai drasticamente

SoluÃ§Ã£o: renovaÃ§Ã£o automÃ¡tica com certbot ou serviÃ§os como Cloudflare.
