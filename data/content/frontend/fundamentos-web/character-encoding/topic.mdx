---
title: "CodificaÃ§Ã£o de Caracteres (UTF-8, Unicode)"
slug: "character-encoding"
room: "frontend"
category: "fundamentos-web"
difficulty: "beginner"
order: 25
prerequisites: []
tags: ["utf-8", "unicode", "ascii", "encoding"]
aiGenerated: true
---

## O que Ã©

CodificaÃ§Ã£o de caracteres Ã© o **mapeamento entre caracteres humanos e nÃºmeros que o computador armazena**. Computadores guardam bytes (nÃºmeros de 0 a 255) â€” a codificaÃ§Ã£o define qual nÃºmero corresponde a qual caractere.

```
CodificaÃ§Ã£o Ã© um "dicionÃ¡rio" bidirecional:

'A' â†” 65      (ASCII, UTF-8, Latin-1 â€” todos concordam)
'Ã©' â†” 233     (Latin-1: 1 byte)
'Ã©' â†” 195 169 (UTF-8: 2 bytes)
'ğŸ˜€' â†” 240 159 152 128 (UTF-8: 4 bytes)
```

Pense em codificaÃ§Ã£o como uma **tabela de traduÃ§Ã£o**: o remetente e o destinatÃ¡rio precisam usar a mesma tabela. Se um escreve usando uma tabela e o outro lÃª usando outra, o resultado Ã© texto ilegÃ­vel â€” o famoso **mojibake**: "OlÃ¡" vira "OlÃƒÂ¡", "SÃ£o Paulo" vira "SÃƒÂ£o Paulo".

## Por que importa

A web inteira Ã© texto â€” HTML, CSS, JavaScript, JSON, URLs. Se a codificaÃ§Ã£o estiver errada, o texto quebra:

```
Encoding correto (UTF-8 â†’ UTF-8):
"ProgramaÃ§Ã£o em SÃ£o Paulo" âœ…

Encoding errado (UTF-8 â†’ Latin-1):
"ProgramaÃƒÂ§ÃƒÂ£o em SÃƒÂ£o Paulo" âŒ (mojibake)
```

Isso acontece na prÃ¡tica quando:
- `<meta charset>` estÃ¡ ausente ou errado no HTML
- O servidor envia `Content-Type` sem charset
- Um arquivo Ã© salvo em Latin-1 mas lido como UTF-8
- O banco de dados usa uma codificaÃ§Ã£o diferente da aplicaÃ§Ã£o

Para desenvolvedores brasileiros, isso Ã© especialmente relevante: caracteres como **Ã£, Ã©, Ã§, Ã³, Ã¼** ocupam mais de 1 byte em UTF-8 e sÃ£o os primeiros a quebrar quando a codificaÃ§Ã£o estÃ¡ errada.

**Hoje, UTF-8 Ã© o padrÃ£o universal** â€” mais de 98% das pÃ¡ginas web usam UTF-8. Mas entender *por que* UTF-8 Ã© o padrÃ£o (e o que veio antes) evita bugs que parecem "mÃ¡gicos" quando aparecem.

## Como funciona

### A evoluÃ§Ã£o das codificaÃ§Ãµes

```
1963  ASCII         7 bits   128 caracteres    SÃ³ inglÃªs (A-Z, 0-9, sÃ­mbolos)
1985  Latin-1       8 bits   256 caracteres    + europeu ocidental (Ã£, Ã©, Ã±, Ã¼)
1991  Unicode       --       149.186+ chars    CatÃ¡logo universal de caracteres
1993  UTF-8         1-4 bytes  Unicode          Encoding eficiente de Unicode
```

### ASCII (1963): o comeÃ§o

ASCII usa 7 bits (0-127) para mapear 128 caracteres:

```
Dec  Char â”‚ Dec  Char â”‚ Dec  Char
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 32  (espaÃ§o) â”‚  48  '0'  â”‚  65  'A'
 33  '!'  â”‚  49  '1'  â”‚  66  'B'
 34  '"'  â”‚  ...      â”‚  ...
 ...      â”‚  57  '9'  â”‚  90  'Z'
 47  '/'  â”‚  64  '@'  â”‚  97  'a'
                      â”‚  122 'z'
```

ASCII funciona perfeitamente â€” para inglÃªs. Sem acentos, sem cedilha, sem ideogramas, sem emoji. O byte 195 nÃ£o significa nada em ASCII.

### Latin-1 / ISO-8859-1 (1985): extensÃ£o para Europa Ocidental

Latin-1 usa 8 bits (0-255). Os primeiros 128 sÃ£o idÃªnticos ao ASCII. Os 128 extras cobrem europeu ocidental:

```
Dec  Char â”‚ DescriÃ§Ã£o
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 224  'Ã '  â”‚ a com acento grave
 225  'Ã¡'  â”‚ a com acento agudo
 227  'Ã£'  â”‚ a com til
 231  'Ã§'  â”‚ c com cedilha
 233  'Ã©'  â”‚ e com acento agudo
 241  'Ã±'  â”‚ n com til (espanhol)
```

Problema: 256 caracteres nÃ£o cobrem o mundo. ChinÃªs tem ~50.000 ideogramas, japonÃªs tem 3 escritas diferentes, Ã¡rabe, hebraico, tailandÃªs... Cada regiÃ£o criou sua prÃ³pria codificaÃ§Ã£o (ISO-8859-2 para Europa Oriental, Shift_JIS para japonÃªs, GB2312 para chinÃªs). Resultado: caos â€” o mesmo byte 195 significa "Ãƒ" em Latin-1, "Äƒ" em Latin-2, e outra coisa em Shift_JIS.

### Unicode (1991): o catÃ¡logo universal

Unicode resolve o problema com uma abordagem radical: **catalogar todos os caracteres de todos os idiomas do mundo** em uma tabela Ãºnica.

```
Cada caractere recebe um "code point" Ãºnico:

U+0041  'A'    (Latin Capital Letter A)
U+00E9  'Ã©'    (Latin Small Letter E with Acute)
U+00E3  'Ã£'    (Latin Small Letter A with Tilde)
U+4E16  'ä¸–'   (CJK Unified Ideograph â€” "mundo" em chinÃªs)
U+1F600 'ğŸ˜€'   (Grinning Face)
U+1F1E7 'ğŸ‡§'   (Regional Indicator B â€” parte da bandeira ğŸ‡§ğŸ‡·)
```

Unicode hoje define **149.000+** caracteres, incluindo todos os idiomas vivos, sistemas de escrita histÃ³ricos (hierÃ³glifos egÃ­pcios!), sÃ­mbolos matemÃ¡ticos, e emoji.

**Importante:** Unicode Ã© o **catÃ¡logo** (qual nÃºmero = qual caractere). Mas como armazenar esses nÃºmeros em bytes? AÃ­ entram os *encodings*.

### UTF-8 (1993): o encoding que venceu

UTF-8 Ã© uma forma de **codificar code points Unicode em bytes**. Usa **largura variÃ¡vel**: 1 a 4 bytes por caractere.

```
Code Point Range      â”‚ Bytes â”‚ PadrÃ£o de Bits        â”‚ Exemplos
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
U+0000  a U+007F      â”‚   1   â”‚ 0xxxxxxx              â”‚ A, z, 0, @
U+0080  a U+07FF      â”‚   2   â”‚ 110xxxxx 10xxxxxx     â”‚ Ã£, Ã©, Ã§, Ã±
U+0800  a U+FFFF      â”‚   3   â”‚ 1110xxxx 10xxxxxx Ã—2  â”‚ ä¸–, â‚¬, â‚¹
U+10000 a U+10FFFF    â”‚   4   â”‚ 11110xxx 10xxxxxx Ã—3  â”‚ ğŸ˜€, ğŸ‰, ğ•³
```

**Exemplo concreto** â€” como "Ã©" (U+00E9) vira bytes UTF-8:

```
U+00E9 em binÃ¡rio: 11101001

PadrÃ£o de 2 bytes: 110xxxxx 10xxxxxx
Preenchendo:       110.00011 10.101001
Em hexadecimal:    0xC3      0xA9
Em decimal:        195       169

Resultado: "Ã©" = 2 bytes [0xC3, 0xA9] em UTF-8
```

Ã‰ por isso que quando Latin-1 lÃª esses 2 bytes, vÃª "ÃƒÂ©" (195 = Ãƒ, 169 = Â©) em vez de "Ã©".

### Por que UTF-8 venceu

```
âœ… CompatÃ­vel com ASCII â€” textos ASCII puros sÃ£o UTF-8 vÃ¡lidos (1 byte cada)
âœ… Eficiente para texto latino â€” portuguÃªs usa 1 byte para letras comuns, 2 para acentuadas
âœ… Universal â€” suporta TODOS os caracteres Unicode
âœ… Self-synchronizing â€” possÃ­vel encontrar o inÃ­cio de um caractere a partir de qualquer byte
âœ… Sem ambiguidade â€” a mesma sequÃªncia de bytes sempre significa a mesma coisa
```

### Como o navegador determina a codificaÃ§Ã£o

O navegador verifica nesta ordem de prioridade:

```
1. BOM (Byte Order Mark) â€” bytes mÃ¡gicos no inÃ­cio do arquivo
   UTF-8 BOM: EF BB BF (raro e geralmente desnecessÃ¡rio)

2. HTTP header
   Content-Type: text/html; charset=utf-8

3. <meta> tag no HTML (deve estar nos primeiros 1024 bytes)
   <meta charset="UTF-8">

4. HeurÃ­stica â€” o navegador tenta adivinhar (resultado imprevisÃ­vel)
```

Se nenhum dos 3 primeiros estiver presente, o navegador **adivinha** â€” e frequentemente erra, especialmente com caracteres portugueses.

## Na prÃ¡tica

### Declarar encoding no HTML

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <!-- DEVE ser a primeira tag dentro de <head> -->
  <!-- O navegador precisa saber a codificaÃ§Ã£o ANTES de interpretar qualquer texto -->
  <meta charset="UTF-8">
  <title>ProgramaÃ§Ã£o</title>
</head>
```

### String length vs byte length

```javascript
// JavaScript usa UTF-16 internamente para strings
// .length conta unidades de cÃ³digo UTF-16, NÃƒO caracteres visuais

"hello".length;     // 5 â€” ASCII simples, 1 unidade cada
"cafÃ©".length;      // 4 â€” Ã© usa 1 unidade UTF-16
"ğŸ˜€".length;        // 2 â€” emoji usa 2 unidades UTF-16 (surrogate pair!)
"ğŸ‡§ğŸ‡·".length;       // 4 â€” bandeira = 2 emojis Ã— 2 unidades cada

// Para contar caracteres visuais (grapheme clusters)
[..."ğŸ˜€"].length;                           // 1 â€” spread usa iteraÃ§Ã£o por code point
new Intl.Segmenter().segment("ğŸ‡§ğŸ‡·");       // 1 segmento (a bandeira inteira)

// Para contar bytes em UTF-8
new TextEncoder().encode("cafÃ©").length;    // 5 bytes (c=1, a=1, f=1, Ã©=2)
new TextEncoder().encode("ğŸ˜€").length;      // 4 bytes
```

### TextEncoder e TextDecoder

```javascript
// Converter string â†’ bytes UTF-8
const encoder = new TextEncoder(); // sempre UTF-8
const bytes = encoder.encode("OlÃ¡, SÃ£o Paulo!");
// Uint8Array [79, 108, 195, 161, 44, 32, 83, 195, 163, 111, 32, ...]
// "Ã¡" = [195, 161] (2 bytes), "Ã£" = [195, 163] (2 bytes)

// Converter bytes â†’ string
const decoder = new TextDecoder("utf-8");
const texto = decoder.decode(bytes);
// "OlÃ¡, SÃ£o Paulo!"

// Ler arquivo com encoding especÃ­fico
const decoder = new TextDecoder("iso-8859-1"); // Latin-1
const response = await fetch("/arquivo-legado.txt");
const buffer = await response.arrayBuffer();
const texto = decoder.decode(buffer);
```

### FormulÃ¡rios HTML

```html
<!-- FormulÃ¡rios enviam dados codificados -->
<!-- O encoding do formulÃ¡rio segue o encoding do documento -->

<!-- Com accept-charset, vocÃª pode forÃ§ar UTF-8 -->
<form action="/api/busca" accept-charset="UTF-8">
  <input name="q" value="programaÃ§Ã£o">
  <!-- Enviado como: q=programa%C3%A7%C3%A3o -->
  <!-- Ã§ = %C3%A7, Ã£ = %C3%A3 (bytes UTF-8 percent-encoded) -->
</form>
```

<CodeTabs />

## Quando usar (e quando nÃ£o usar)

### Sempre use UTF-8

```
UTF-8 Ã© o padrÃ£o para:
- HTML (meta charset="UTF-8")
- HTTP (Content-Type: text/html; charset=utf-8)
- JSON (especificaÃ§Ã£o exige UTF-8)
- JavaScript (source files)
- Bancos de dados modernos
- APIs

NÃ£o existe motivo para usar outra codificaÃ§Ã£o em projetos novos.
```

### Quando vocÃª encontra outras codificaÃ§Ãµes

- **Sistemas legados** â€” mainframes bancÃ¡rios, ERPs antigos, arquivos de governo
- **Arquivos CSV** â€” Excel brasileiro salva como Windows-1252 por padrÃ£o
- **Emails** â€” MIME suporta vÃ¡rias codificaÃ§Ãµes
- **Bancos de dados antigos** â€” MySQL com `latin1` ao invÃ©s de `utf8mb4`

Nestes casos, use `TextDecoder` com o encoding correto para converter para UTF-8.

### UTF-8 vs UTF-16

```
UTF-8:  variÃ¡vel (1-4 bytes)
- Mais compacto para texto latino (portuguÃªs, inglÃªs, espanhol)
- "OlÃ¡" = 4 bytes em UTF-8

UTF-16: variÃ¡vel (2 ou 4 bytes)
- Mais compacto para texto CJK (chinÃªs, japonÃªs, coreano)
- "OlÃ¡" = 8 bytes em UTF-16 (mÃ­nimo 2 bytes por caractere)

JavaScript usa UTF-16 internamente (heranÃ§a histÃ³rica),
mas transmite como UTF-8 na rede.
```

## Erros comuns

### 1. NÃ£o declarar charset no HTML

```html
<!-- âŒ Sem charset â€” navegador adivinha (e pode errar) -->
<head>
  <title>ProgramaÃ§Ã£o</title>
</head>

<!-- âœ… Charset como primeira tag do head -->
<head>
  <meta charset="UTF-8">
  <title>ProgramaÃ§Ã£o</title>
</head>
```

Se o `<meta charset>` nÃ£o estÃ¡ nos primeiros 1024 bytes do HTML, o navegador pode comeÃ§ar a renderizar com a codificaÃ§Ã£o errada e depois ter que recomeÃ§ar.

### 2. Confundir Unicode com UTF-8

```
Unicode â‰  UTF-8

Unicode Ã© o CATÃLOGO: "o caractere 'Ã©' Ã© o nÃºmero U+00E9"
UTF-8 Ã© um ENCODING: "U+00E9 Ã© armazenado como os bytes 0xC3 0xA9"

Outras formas de armazenar Unicode:
- UTF-16: U+00E9 â†’ 0x00E9 (2 bytes)
- UTF-32: U+00E9 â†’ 0x000000E9 (4 bytes)

Todos representam os mesmos caracteres, mas usam bytes diferentes.
```

### 3. Assumir 1 caractere = 1 byte

```javascript
// âŒ Calcular tamanho de upload pela string length
const texto = "ProgramaÃ§Ã£o avanÃ§ada";
const tamanhoEstimado = texto.length; // 20
const tamanhoReal = new TextEncoder().encode(texto).length; // 22
// "Ã£" e "Ã§" ocupam 2 bytes cada em UTF-8

// âŒ Truncar string por bytes pode cortar um caractere no meio
const bytes = new TextEncoder().encode("SÃ£o Paulo");
const cortado = bytes.slice(0, 3); // [83, 195, 163] â€” corta "Ã£" no meio?
// NÃ£o: "Ã£" comeÃ§a no byte 1 (195, 163), byte 0 Ã© "S"
// bytes.slice(0, 2) = [83, 195] â€” cortou "Ã£" no meio! Byte 195 sozinho Ã© invÃ¡lido
```

### 4. Emoji e string.length

```javascript
// JavaScript .length conta unidades UTF-16, nÃ£o caracteres visuais

"a".length;      // 1 âœ…
"Ã©".length;      // 1 âœ… (BMP, 1 unidade UTF-16)
"ğŸ˜€".length;     // 2 âŒ (precisa de surrogate pair)
"ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦".length; // 11 âŒ (4 emojis + 3 zero-width joiners)

// Para contar grafemas (caracteres visuais):
const segmenter = new Intl.Segmenter("pt-BR", { granularity: "grapheme" });
[...segmenter.segment("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦")].length; // 1 âœ…
```

### 5. Misturar codificaÃ§Ãµes no mesmo sistema

```
Banco de dados: Latin-1
AplicaÃ§Ã£o: UTF-8
Arquivo CSV: Windows-1252

Resultado: "SÃ£o Paulo" no banco vira "SÃƒÂ£o Paulo" na tela

SoluÃ§Ã£o: padronize UTF-8 em TODAS as camadas.
Banco: ALTER DATABASE SET CHARACTER SET utf8mb4;
Arquivos: salvar como UTF-8 (verificar no editor)
HTTP: Content-Type com charset=utf-8
```

### 6. BOM em arquivos UTF-8

```
BOM (Byte Order Mark) = 3 bytes mÃ¡gicos no inÃ­cio: EF BB BF

Em UTF-16, o BOM Ã© necessÃ¡rio (indica byte order).
Em UTF-8, o BOM Ã© DESNECESSÃRIO e causa problemas:

- PHP: BOM antes de <?php gera "headers already sent"
- JSON: BOM no inÃ­cio torna o JSON invÃ¡lido
- CSV: Excel nÃ£o reconhece sem BOM (mas outros programas quebram com BOM)
- Shell scripts: #!/bin/bash com BOM nÃ£o funciona

Regra: salve arquivos UTF-8 SEM BOM (a maioria dos editores modernos jÃ¡ faz isso).
```
