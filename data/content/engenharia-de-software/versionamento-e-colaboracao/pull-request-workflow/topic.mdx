---
title: "Pull Request Workflow"
slug: "pull-request-workflow"
room: "engenharia-de-software"
category: "versionamento-e-colaboracao"
difficulty: "beginner"
order: 3
prerequisites: ["branching-strategies"]
tags: ["revisao", "colaboracao", "qualidade"]
aiGenerated: true
---

## O que Ã©

Um Pull Request (PR) â€” ou Merge Request (MR) no GitLab â€” Ã© uma **proposta formal de integrar mudanÃ§as** de uma branch para outra. NÃ£o Ã© apenas um merge: Ã© um processo que inclui revisÃ£o de cÃ³digo, discussÃ£o, testes automatizados e aprovaÃ§Ã£o antes da integraÃ§Ã£o.

```
feature/add-search â”€â”€â—â”€â”€â—â”€â”€â—â”€â”€â†’ Pull Request â†’ RevisÃ£o â†’ âœ… Aprovado â†’ Merge para main
```

O PR Ã© o **checkpoint de qualidade** entre "cÃ³digo escrito" e "cÃ³digo em produÃ§Ã£o".

## Por que importa

Sem Pull Requests:
- CÃ³digo vai para produÃ§Ã£o sem revisÃ£o â€” bugs passam despercebidos
- NÃ£o hÃ¡ registro de **por que** uma mudanÃ§a foi feita
- Novos membros da equipe nÃ£o aprendem com o cÃ³digo dos outros
- PadrÃµes de qualidade dependem da disciplina individual

Com Pull Requests:
- **RevisÃ£o de cÃ³digo:** pelo menos uma pessoa verifica cada mudanÃ§a
- **DocumentaÃ§Ã£o viva:** PRs formam um histÃ³rico pesquisÃ¡vel de decisÃµes
- **Testes automatizados:** CI roda antes do merge (testes, lint, build)
- **TransferÃªncia de conhecimento:** revisores aprendem sobre partes do cÃ³digo que nÃ£o escreveram

Estudos mostram que code review Ã© uma das prÃ¡ticas mais eficazes para reduzir defeitos em software â€” mais eficaz atÃ© que testes automatizados sozinhos.

## Como funciona

### O ciclo de vida de um PR

```
1. Criar branch    â†’ Desenvolver na branch
2. Push            â†’ Enviar para o remoto
3. Abrir PR        â†’ Descrever mudanÃ§as, contexto
4. CI/CD           â†’ Testes, lint, build automÃ¡ticos
5. RevisÃ£o         â†’ Colegas revisam cÃ³digo
6. Feedback        â†’ DiscussÃ£o, sugestÃµes, correÃ§Ãµes
7. AprovaÃ§Ã£o       â†’ Reviewer aprova
8. Merge           â†’ Integrar na branch principal
9. Cleanup         â†’ Deletar branch
```

### Anatomia de um bom PR

**TÃ­tulo:** curto e descritivo
```
âœ… "feat: adicionar busca de produtos por categoria"
âŒ "MudanÃ§as"
âŒ "WIP ainda testando"
```

**DescriÃ§Ã£o:** contexto, motivaÃ§Ã£o e o que testar

```markdown
## O que mudou
- Adicionado endpoint GET /products?category=electronics
- Adicionado filtro por categoria na listagem de produtos
- Adicionado Ã­ndice no banco para a coluna category

## Por que
UsuÃ¡rios reportaram que nÃ£o conseguem filtrar produtos.
Issue: #342

## Como testar
1. GET /products?category=electronics â†’ deve retornar sÃ³ eletrÃ´nicos
2. GET /products â†’ deve retornar todos (sem filtro)
3. GET /products?category=inexistente â†’ deve retornar array vazio
```

### Tamanho ideal de um PR

| Tamanho | Linhas alteradas | Qualidade da revisÃ£o |
|---|---|---|
| Pequeno | < 200 linhas | Excelente â€” revisor foca nos detalhes |
| MÃ©dio | 200-400 linhas | Boa â€” revisor consegue acompanhar |
| Grande | 400-1000 linhas | Fraca â€” revisor comeÃ§a a "ler por cima" |
| Enorme | > 1000 linhas | PÃ©ssima â€” revisor aprova sem ler ("LGTM") |

**Regra:** se o PR estÃ¡ grande, quebre em PRs menores e sequenciais. Um PR que adiciona o endpoint, outro que adiciona os testes, outro que adiciona o filtro na UI.

### Como fazer uma boa revisÃ£o

**O que verificar:**
1. **CorreÃ§Ã£o:** o cÃ³digo faz o que propÃµe fazer?
2. **Edge cases:** trata erros, valores nulos, limites?
3. **Performance:** tem loops desnecessÃ¡rios, queries repetitivas ao banco (N+1)?
4. **SeguranÃ§a:** valida input, escapa output, trata autenticaÃ§Ã£o?
5. **Legibilidade:** nomes claros, funÃ§Ãµes pequenas, sem cÃ³digo morto?
6. **Testes:** mudanÃ§as estÃ£o testadas? Testes cobrem edge cases?

**Como dar feedback:**
```
âœ… "Essa query pode ter N+1 se a lista tiver muitos items.
    SugestÃ£o: usar eager loading aqui."

âŒ "CÃ³digo ruim."
âŒ "Eu faria diferente." (sem explicar como/por quÃª)
```

Feedback deve ser **especÃ­fico, construtivo e respeitoso**. Foque no cÃ³digo, nÃ£o na pessoa.

### CI/CD no PR

Antes do merge, pipelines automÃ¡ticas verificam:

```
PR aberto â†’ Testes unitÃ¡rios âœ…
           â†’ Testes de integraÃ§Ã£o âœ…
           â†’ Lint/Format âœ…
           â†’ Build âœ…
           â†’ Security scan âœ…
           â†’ Coverage report ğŸ“Š
```

Se qualquer check falhar, o merge Ã© bloqueado atÃ© a correÃ§Ã£o.

## Na prÃ¡tica

Fluxo completo via terminal + GitHub CLI:

```bash
# 1. Criar branch e desenvolver
git checkout -b feature/add-search
# (fazer mudanÃ§as, commitar)

# 2. Push
git push -u origin feature/add-search

# 3. Abrir PR via GitHub CLI
gh pr create \
  --title "feat: adicionar busca de produtos" \
  --body "Adiciona endpoint de busca com filtro por categoria. Issue #342"

# 4. Ver status dos checks
gh pr checks

# 5. Pedir revisÃ£o
gh pr edit --add-reviewer colega1,colega2

# 6. ApÃ³s aprovaÃ§Ã£o, merge
gh pr merge --squash --delete-branch
```

## Quando usar (e quando nÃ£o usar)

### Sempre use PRs quando:
- Trabalha em equipe (mesmo que sejam sÃ³ 2 pessoas)
- O cÃ³digo vai para produÃ§Ã£o
- Quer manter histÃ³rico de decisÃµes

### Pode pular PRs quando:
- Projeto pessoal solo (mas ainda assim Ã© boa prÃ¡tica)
- Hotfix emergencial (faÃ§a o PR retroativo depois)
- MudanÃ§as triviais (typo no README, atualizar .gitignore)

## Erros comuns

### 1. PR gigante ("mega PR")

```
PR com 3.000 linhas alteradas, 45 arquivos, 12 features diferentes
â†’ Revisor nÃ£o consegue revisar com qualidade
â†’ Aprova sem ler ("LGTM ğŸ‘")
â†’ Bugs passam para produÃ§Ã£o
```

SoluÃ§Ã£o: quebrar em PRs menores de 200-400 linhas.

### 2. NÃ£o descrever o contexto

```
TÃ­tulo: "fix bug"
DescriÃ§Ã£o: (vazio)

â†’ Revisor nÃ£o sabe o que olhar
â†’ RevisÃ£o superficial ou demorada
```

Sempre inclua: o que mudou, por que mudou, como testar.

### 3. Levar feedback para o pessoal

Code review Ã© sobre o **cÃ³digo**, nÃ£o sobre vocÃª. "Essa variÃ¡vel poderia ter um nome mais descritivo" nÃ£o Ã© um ataque pessoal â€” Ã© uma sugestÃ£o para melhorar o cÃ³digo que vocÃªs compartilham.

### 4. NÃ£o responder ao feedback

```
Revisor: "Essa query pode ter problemas de performance com muitos registros"
Autor: (silÃªncio, merge mesmo assim)
```

Sempre responda ao feedback: concordar e corrigir, discordar e explicar, ou pedir mais contexto.

### 5. Aprovar sem revisar ("rubber stamping")

Se vocÃª nÃ£o tem tempo para revisar, diga. Um "LGTM" sem ler o cÃ³digo Ã© pior do que nenhuma revisÃ£o â€” cria falsa sensaÃ§Ã£o de seguranÃ§a.
