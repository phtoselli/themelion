---
title: "Arrays e Strings"
slug: "arrays"
room: "fundamentos"
category: "estruturas-de-dados"
difficulty: "beginner"
order: 1
prerequisites: ["big-o-notation"]
tags: ["performance", "busca", "indice"]
aiGenerated: true
---

## O que é

Imagine um estacionamento com vagas numeradas (0, 1, 2, 3...). Cada vaga guarda um carro, e você pode ir direto para a vaga 47 sem passar pelas 46 anteriores. **Array** funciona exatamente assim: um bloco contíguo de memória onde cada elemento tem um endereço calculável instantaneamente a partir do seu índice.

Formalmente: um array é uma estrutura de dados que armazena elementos em **posições contíguas** de memória, permitindo **acesso aleatório** (random access) em tempo constante O(1) através de um índice numérico inteiro começando em 0.

**Strings** são, na maioria das linguagens modernas, arrays de caracteres (ou bytes) com operações especializadas. Tudo que você aprender sobre arrays se aplica a strings: acesso por índice, slicing, iteração.

## Por que importa

Arrays resolvem o problema da **agregação e acesso eficiente** a coleções de dados.

**Antes dos arrays (ou sem eles):**
```python
nota1 = 8.5
nota2 = 7.0
nota3 = 9.2
# ...
nota100 = 6.8

# Calcular média? Escrever 100 linhas de soma manual?
# Impossível de escalar, código repetitivo, manutenção inviável.
```

**Com arrays:**
```python
notas = [8.5, 7.0, 9.2, ..., 6.8]
media = sum(notas) / len(notas)  # 2 linhas para qualquer quantidade de notas
```

Arrays são a estrutura de dados **mais fundamental** da computação. Quase toda estrutura de dados avançada (stacks, queues, heaps, hash tables) é construída usando arrays como base. Se você dominar arrays, você:

1. Entende como a memória funciona (endereçamento, cache, localidade espacial)
2. Compreende complexidade de algoritmos (O(1) vs O(n) na prática)
3. Sabe escolher a estrutura certa para cada problema
4. Tem a base para entender todas as estruturas de dados que virão depois

## Como funciona

### Representação em memória

Arrays alocam um **bloco contíguo de memória**. Se você criar um array de 5 inteiros em uma linguagem onde int ocupa 4 bytes, o sistema operacional reserva 20 bytes consecutivos na RAM.

Exemplo concreto:
```
arr = [10, 20, 30, 40, 50]

Memória:
Posição    Valor
1000   →   10    # arr[0]
1004   →   20    # arr[1]
1008   →   30    # arr[2]
1012   →   40    # arr[3]
1016   →   50    # arr[4]
```

O endereço de qualquer elemento é calculado com uma **fórmula matemática simples**:

```
endereço(arr[i]) = endereço_base + (i × tamanho_do_elemento)
```

Para acessar `arr[3]`:
```
posição(arr[3]) = 1000 + (3 × 4) = 1012
```

O computador faz essa conta instantaneamente — é só uma multiplicação e uma soma. Não importa se o array tem 5 ou 5 milhões de elementos: acessar qualquer posição é igualmente rápido. Isso é o que significa **O(1)** (tempo constante).

### Arrays estáticos vs dinâmicos

**Arrays estáticos (C, C++, Rust, Go):**
- Tamanho fixo definido na criação
- Memória alocada em regiões fixas da RAM
- Sem overhead de memória extra
- Não podem crescer ou encolher

**Arrays dinâmicos (Python `list`, JavaScript `Array`, C# `List<T>`, Go `slice`):**
- Tamanho variável, crescem conforme necessário
- Internamente, alocam **mais memória do que precisam** (como comprar uma mochila maior do que você precisa agora)
- Quando a capacidade esgota, realo cam um bloco maior e copiam tudo
- Estratégia comum: duplicar o tamanho (capacidade × 2) quando encher

Exemplo em Python:
```python
lista = []           # capacidade inicial: 0
lista.append(1)      # capacidade cresce para 4
lista.append(2)      # capacidade ainda 4
lista.append(3)      # capacidade ainda 4
lista.append(4)      # capacidade ainda 4
lista.append(5)      # capacidade cresce para 8 (copia tudo)
```

Essa estratégia de duplicação é como comprar uma mochila maior do que você precisa: quando ela enche, você compra uma ainda maior e transfere tudo. Parece desperdício, mas na prática você troca de mochila poucas vezes. O custo "médio" de guardar cada item acaba sendo muito baixo — **O(1) por inserção** na média.

### Complexidade das operações

| Operação | Complexidade | Por quê |
|---|---|---|
| **Acesso por índice** `arr[i]` | O(1) | Cálculo direto do endereço |
| **Modificação** `arr[i] = x` | O(1) | Cálculo direto do endereço |
| **Busca por valor** `x in arr` | O(n) | Precisa comparar com cada elemento até encontrar |
| **Append (final)** `arr.append(x)` | O(1) amortizado | Só incrementa ponteiro (ou realoca ocasionalmente) |
| **Pop (final)** `arr.pop()` | O(1) | Só decrementa ponteiro |
| **Insert (meio)** `arr.insert(i, x)` | O(n) | Precisa mover todos os elementos após o índice i |
| **Remove (meio)** `arr.remove(x)` | O(n) | Busca O(n) + mover elementos O(n) |
| **Slicing** `arr[i:j]` | O(k) | k = tamanho do slice, copia k elementos |

**Por que inserir no meio é O(n)?**

```python
arr = [1, 2, 3, 4, 5]
arr.insert(1, 99)  # Inserir 99 na posição 1

# O que acontece internamente:
# 1. Verificar capacidade (se não houver espaço, realocar tudo)
# 2. Mover [2, 3, 4, 5] uma posição à direita
#    - arr[5] = arr[4]  # 5
#    - arr[4] = arr[3]  # 4
#    - arr[3] = arr[2]  # 3
#    - arr[2] = arr[1]  # 2
# 3. Colocar 99 na posição 1
# Resultado: [1, 99, 2, 3, 4, 5]

# Mover n elementos = O(n)
```

### Aprofundamento: como linguagens diferentes armazenam arrays

Em linguagens de baixo nível (C, C++, Rust), o array guarda os valores diretamente na memória. Em linguagens de alto nível (Python, JavaScript, Java), o array guarda "referências" que apontam para onde os valores realmente estão. Na prática, isso significa que acessar um elemento em Python faz um pouco mais de trabalho interno do que em C, mas você não precisa se preocupar com isso na maioria dos casos.

### Strings como arrays especiais

Strings são arrays de caracteres com propriedades extras:

**Imutabilidade (Python, Java, C#, Go, Rust):**
```python
s = "hello"
s[0] = "H"  # ERRO! Strings são imutáveis
```

Por quê imutáveis? Porque isso permite várias otimizações internas: strings iguais podem compartilhar a mesma memória, múltiplas partes do programa podem ler a mesma string ao mesmo tempo sem conflitos, e o "hash" (código de identificação) da string é calculado uma única vez e guardado.

**Concatenação ingênua = O(n²):**
```python
# ❌ O(n²) - cada += cria nova string e copia tudo
result = ""
for word in words:  # n palavras
    result += word  # O(comprimento atual) a cada iteração

# ✅ O(n) - aloca tamanho final de uma vez
result = "".join(words)  # Calcula tamanho total, aloca, copia cada palavra uma vez
```

**Encoding (como caracteres são armazenados):**
Caracteres como emojis e letras acentuadas podem ocupar mais espaço na memória do que letras simples (como "a" ou "z"). Por isso, em algumas linguagens, acessar o "quinto caractere" de uma string não é tão simples quanto acessar o quinto item de um array de números — o computador pode precisar contar os bytes de cada caractere anterior para encontrar a posição certa.

## Na prática

<CodeTabs />

## Quando usar (e quando não usar)

### Use arrays quando:

**1. Acesso por índice é a operação principal**
```python
# Processar pixels de uma imagem (milhões de acessos aleatórios)
pixels = image.get_pixels()
for y in range(height):
    for x in range(width):
        pixel = pixels[y * width + x]  # O(1) acesso direto
        process(pixel)
```
Alternativa (linked list): O(n) para cada acesso = O(n²) total. Inviável.

**2. Iteração sequencial sobre todos os elementos**
```python
# Somar todos os valores
total = sum(arr)  # CPU processa isso em ~10 ciclos por elemento (cache friendly)
```
Dados que estão lado a lado na memória são processados muito mais rápido pelo computador (é como ler páginas seguidas de um livro, em vez de pular entre capítulos aleatórios). Arrays aproveitam isso naturalmente.

**3. Tamanho conhecido ou cresce previsívelmente**
- Lendo arquivo CSV de 1 milhão de linhas → você sabe quantos elementos terá
- Processamento batch → tamanho fixo por lote
- Arrays dinâmicos crescem bem se você fizer append no final

**4. Algoritmos que dependem de acesso aleatório**
- **Busca binária** em array ordenado: O(log n)
- **Quick sort** (pivoting requer acesso direto)
- **Heap** (acessar pai/filhos via índices: `pai = i // 2`, `filho = 2*i`)

**5. Memory-mapped files e buffers de I/O**
Sistemas operacionais usam arrays para:
- Buffers de rede
- Frames de vídeo
- Dados de sensores (IoT, embedded systems)

### Não use arrays quando:

**1. Inserções/remoções frequentes no meio**
```python
# ❌ Array: O(n) por inserção
for i in range(1000):
    arr.insert(random_index, value)  # Move metade do array em média
# Total: O(n²) = 1 milhão de operações

# ✅ Linked list: O(1) inserção se você já tem o nó
```
**Exceção:** se você pode fazer inserções em batch e depois ordenar, pode valer a pena.

**2. Busca por chave (não por índice)**
```python
# ❌ Array: buscar usuário por email = O(n)
users = [user1, user2, ..., user1000000]
user = next(u for u in users if u.email == "john@example.com")  # Percorre tudo

# ✅ Hash table: O(1) lookup
users = {"john@example.com": user1, ...}
user = users["john@example.com"]  # Direto
```

**3. Precisa garantir unicidade (sem duplicatas)**
```python
# ❌ Array: verificar duplicata = O(n) antes de cada inserção
if value not in arr:  # O(n)
    arr.append(value)

# ✅ Set: O(1) inserção + garante unicidade automaticamente
my_set.add(value)
```

**4. Tamanho extremamente variável e imprevisível**
Se o tamanho varia de 10 a 10 milhões de forma imprevisível:
- Array dinâmico desperdiça memória (overallocation)
- Realocações constantes matam performance
- Considere estruturas fragmentadas (chunked arrays, rope para strings)

**5. Precisa de ordenação mantida automaticamente**
```python
# ❌ Array: inserir mantendo ordem = O(n)
# Busca binária para achar posição: O(log n)
# Inserir na posição: O(n) - mover elementos
index = bisect.bisect_left(arr, value)
arr.insert(index, value)

# ✅ Árvore balanceada (TreeSet): O(log n) inserção + mantém ordem
tree.insert(value)
```

### Comparação rápida: Array vs Hash Table

Essas são as duas estruturas que você verá mais no dia a dia:

| Operação | Array | Hash Table |
|---|---|---|
| Acesso por posição (índice) | Instantâneo | Não se aplica |
| Busca por valor/chave | Lento (olha um por um) | Instantâneo |
| Adicionar no final | Instantâneo | Instantâneo |
| Adicionar no meio | Lento (move elementos) | Não se aplica |
| Percorrer tudo em ordem | Muito rápido | Rápido |

**Resumo:** use array quando precisa de acesso por posição ou percorrer tudo em ordem. Use hash table quando precisa buscar por chave (como buscar um usuário por email).

## Erros comuns

### 1. Off-by-one (índice fora do limite)

**O bug mais clássico da programação:**
```python
arr = [10, 20, 30]  # Índices válidos: 0, 1, 2

# ❌ Acessar arr[3] (ou arr[len(arr)])
last = arr[len(arr)]  # IndexError! O último é arr[len(arr) - 1]

# ✅ Correto
last = arr[len(arr) - 1]  # ou arr[-1] em Python
```

**Por que acontece tanto?**
- Humanos contam de 1, arrays começam em 0
- "10 elementos" significa índices de 0 a 9, não 1 a 10
- Loops com `i <= len(arr)` ao invés de `i < len(arr)`

**Em linguagens sem bounds checking (C, C++):**
```c
int arr[5] = {1, 2, 3, 4, 5};
int x = arr[100];  // Sem erro! Lê memória aleatória (undefined behavior)
arr[100] = 99;     // Corrompe memória de outra variável = bug impossível de debugar
```

### 2. Modificar array durante iteração

```python
# ❌ Bug sutil: índices ficam inconsistentes
arr = [1, 2, 3, 4, 5]
for i, value in enumerate(arr):
    if value % 2 == 0:
        arr.remove(value)  # Remove 2, mas pula o 4!

# O que acontece:
# i=0: value=1 (nada)
# i=1: value=2 → remove 2 → arr = [1, 3, 4, 5]
# i=2: value=4 → mas deveria ser 3! (pulou porque os índices mudaram)

# ✅ Opção 1: Criar novo array
arr = [value for value in arr if value % 2 != 0]

# ✅ Opção 2: Iterar de trás pra frente
for i in range(len(arr) - 1, -1, -1):
    if arr[i] % 2 == 0:
        arr.pop(i)
```

### 3. Confundir referência com cópia

```python
# ❌ Não é cópia, é referência!
a = [1, 2, 3]
b = a          # b aponta para o MESMO array
b[0] = 999
print(a)       # [999, 2, 3] - a foi modificado também!

# ✅ Cópia superficial (shallow copy)
b = a.copy()   # ou a[:] ou list(a)
b[0] = 999
print(a)       # [1, 2, 3] - a não mudou

# ⚠️ Cuidado com arrays 2D:
matrix = [[1, 2], [3, 4]]
copy = matrix.copy()  # Shallow copy
copy[0][0] = 999
print(matrix)  # [[999, 2], [3, 4]] - as sublistas são referências!

# ✅ Cópia profunda (deep copy)
import copy
matrix_copy = copy.deepcopy(matrix)
```

**Regra:** em linguagens com tipos de referência (Python, JavaScript, Java, C#):
- Tipos primitivos (int, float, bool) são copiados por valor
- Objetos complexos (arrays, objetos) são copiados por referência

### 4. Busca linear em array grande (quando há alternativas)

```python
# ❌ O(n) lookup repetido = O(n²) total
users = [user1, user2, ..., user100000]
for email in emails_to_find:  # 1000 emails
    user = next(u for u in users if u.email == email)  # O(n) cada
# Total: 1000 × 100000 = 100 milhões de comparações

# ✅ O(n) para construir hash table + O(1) lookup = O(n) total
users_by_email = {u.email: u for u in users}  # O(n)
for email in emails_to_find:
    user = users_by_email[email]  # O(1) cada
# Total: 100000 + 1000 = 101 mil operações (1000x mais rápido)
```

### 5. Concatenação de strings em loop (O(n²) silencioso)

```python
# ❌ O(n²) - cada += cria nova string e copia tudo
result = ""
for word in words:  # 10000 palavras
    result += word + " "
# Iteração 1: copia 1 palavra
# Iteração 2: copia 2 palavras
# ...
# Iteração 10000: copia 10000 palavras
# Total: 1+2+3+...+10000 = 50 milhões de cópias

# ✅ O(n) - join calcula tamanho total, aloca de uma vez, copia cada palavra 1x
result = " ".join(words)  # 10000 cópias
```

**Por que?** Strings são imutáveis. `s += x` não modifica `s`, cria uma **nova** string com o conteúdo de `s` + `x`.

### 6. Usar array quando precisa de fila ou pilha (e vice-versa)

```python
# ❌ Array como fila: remover do início é O(n)
queue = [1, 2, 3, 4, 5]
first = queue.pop(0)  # Remove do início, move [2,3,4,5] uma posição à esquerda

# ✅ Use collections.deque: O(1) em ambas pontas
from collections import deque
queue = deque([1, 2, 3, 4, 5])
first = queue.popleft()  # O(1)

# ✅ Array como pilha (remover do final): perfeito!
stack = [1, 2, 3, 4, 5]
top = stack.pop()  # O(1)
```

### 7. Esquecer que slicing cria cópia (impacto de memória)

```python
# ❌ Criar 1000 cópias de um array gigante
data = list(range(10_000_000))  # 10 milhões de elementos
chunks = [data[i:i+10000] for i in range(0, len(data), 10000)]
# Cada slice cria uma CÓPIA. Memória: 10M elementos × 2 = 20M (dobrou!)

# ✅ Se só precisa ler: use views/iteradores (quando possível)
# Ou processe em streaming sem carregar tudo na memória
```

### 8. Comparar arrays com `==` sem entender semântica

```python
# Python: compara valores (deep equality)
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b)  # True

# JavaScript: compara referências!
let a = [1, 2, 3];
let b = [1, 2, 3];
console.log(a === b);  // False! (são objetos diferentes)
console.log(JSON.stringify(a) === JSON.stringify(b));  // True

# Java: Arrays.equals(a, b) para comparar valores
```

### 9. Acessar array multidimensional com notação errada

```python
# Python: matriz é lista de listas
matrix = [[1, 2], [3, 4]]
x = matrix[0][1]  # Correto: linha 0, coluna 1 = 2

# ❌ Criar matriz 3x3 (armadilha de referências)
matrix = [[0] * 3] * 3  # Cria 3 referências à MESMA lista!
matrix[0][0] = 1
print(matrix)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]] - todas linhas mudaram!

# ✅ Correto:
matrix = [[0] * 3 for _ in range(3)]  # Cria 3 listas diferentes
```

### 10. Ignorar complexidade amortizada (susto com realocações)

```python
# Arrays dinâmicos crescem em saltos (doubling)
arr = []
for i in range(1_000_000):
    arr.append(i)  # O(1) amortizado, mas ocasionalmente O(n) ao realocar
```

Se você está construindo algo que precisa ser rápido o tempo todo sem oscilações (como um jogo que precisa rodar a 60 quadros por segundo):
- Realocações podem causar travamentos momentâneos imprevisíveis
- Solução: pré-alocar tamanho máximo se você souber o limite:
  ```python
  arr = [None] * 1_000_000  # Aloca tudo de uma vez
  ```
